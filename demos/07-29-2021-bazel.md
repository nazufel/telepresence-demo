# Bazel Demo

Here are the steps for running the Bazel demo.

*Note: all commands below assume the reader's current working directory is at the top of this repository and not within the `./docs` directory.

## Demonstration Dependencies

This demonstration has some external dependencies that need to be installed before running Bazel, any Bazel tooling, or Go.

* [Bazel](https://bazel.build) - the bazel build system being demonstrated
* [Bazelisk](https://github.com/bazelbuild/bazelisk) - a wrapper script for enforcing a specific version of bazel
* [Docker](https://docker.com) - package manager and runtime for building and running containerized applications
* [Gazelle](https://github.com/bazelbuild/bazel-gazelle) - a file and dependency manager for building Go applications with bazel
* [Go](https://golang.org) - Go is a popular and highly performant compiled programming language developed and used by Google

## Begin the Demo

Let us begin.
### Overview of Some Key Files

Bazel behavior and build targets are configured with several key files sprinkled across the repository. Let's look at them one-by-one and see what they do. Some files are human-generated while others were made with *gazelle*. 

#### .bazelrc

The [.bazelrc](../.bazelrc) file configures the inter-workings of Bazel, such as where the cache is located and what platform to target for container builds. Please read the comments in the included file and further reading can be found in the [docs](https://docs.bazel.build/versions/main/guide.html#bazelrc-the-bazel-configuration-file). This file was human-generated.

#### .bazelversion

The [.bazelversion](../.bazelversion) file is a simple human-made file that just holds what version of Bazel to use. This file is read by *bazelisk* if using the wrapper, which this demonstration does. This file was human-generated.

The documentation for *bazelisk* is included above. In short, the `bazelisk` command is a one-to-one replacement for `bazel`. This script installs and calls the version of *bazel* defined in the `.bazelversion` file. Below in the code snippets, when you see the command `bazelisk`, `bazel` could also be used. It is recommended to use *bazelisk* or some other wrapper to enforce the use of specific *bazel* versions. 

#### ./BUILD.bazel

There are several `BUILD.bazel` files in this repository. The first one to highlight is at the top of the repo [BUILD.bazel](../BUILD.bazel). Open this file and take a look at the comments. This file is scoped to the top of the workspace. The only thing it is concerned about is configuring *gazelle* and giving *bazel* a target for it. We'll use this later. This top-level file was human-generated.

There are other `BUILD.bazel` files sprinkled throughout the repository. These were generated by *gazelle* and modified by the CODEOWNER. The generated code is separated from the manual code in each file to make it clear what *gazelle* does and what extended behavior the CODEOWNER added. More on these files when the demo gets there.

#### deps.bzl

This file is 100% (other than the comments) generated by *gazelle*. It store references to all of the external Go packages required by the applications. The repositories in this file can be overridden. See [WORKSPACE](../WORKSPACE) line 50 for an example of an override due to an upstream bug.

#### WORKSPACE

Next, take a look at [WORKSPACE](../WORKSPACE), further reading of the docs can be found [here](https://docs.bazel.build/versions/main/be/workspace.html). In short, the WORKSPACE file is a way to define rules for bringing external dependencies into the project. This is the place to load rules libraries, dependency managers (gazelle), and set up the repository. Please go read the comments in the included [WORKSPACE](../WORKSPACE) in this repository before proceeding.

### Running Gazelle

*bazel* is ran with *gazelle* as a target. 

```sh
bazelisk run //:gazelle

INFO: Invocation ID: f0088b6a-eca0-485b-966a-db418f4d4eee
INFO: Analyzed target //:gazelle (0 packages loaded, 0 targets configured).
INFO: Found 1 target...
Target //:gazelle up-to-date:
  bazel-bin/gazelle-runner.bash
  bazel-bin/gazelle
INFO: Elapsed time: 0.125s, Critical Path: 0.00s
INFO: 1 process: 1 internal.
INFO: Build completed successfully, 1 total action
INFO: Build completed successfully, 1 total action
```

*bazelisk* called *bazel* and passed in the `run` sub command with the target `//:gazelle`. The `//` means to look look at where *bazel* is being called from. In this case, it is being called from the top of the repo. Thus, *bazel* looks in the [BUILD.bazel](../BUILD.bazel) file at the top of the repo, and finds the *gazelle* target. *gazelle* then runs to bring in any dependencies defined in the various files it's supposed to look at. This is the **correct** part of the *bazel* tagline. Nothing happens in the above example since *bazel* has cached the previous runs. This is the **fast** part of the *bazel* tagline.

If the other `BUILD.bazel` files weren't generated, then *gazelle* would have built them too. We'll look at those next now that the dependencies are updated.

### Building the Client Binary

There are two Go applications located in the `./cmd` directory at the top of the repository. Within are two directories: `./cmd/client` and `./cmd/server`. Let's focus on the client for this demo, but either will do.

The `./cmd/client` directory has a [main.go](../cmd/client/main.go) file that holds all of the business logic for the *client* application. The *client* is just a gRPC client that periodically sends requests to the server. It is just a single package. 

Let's run the build command:

```sh
bazelisk build //cmd/client:binary

2021/06/30 16:13:44 Downloading https://releases.bazel.build/4.1.0/release/bazel-4.1.0-linux-x86_64...
Extracting Bazel installation...
Starting local Bazel server and connecting to it...
INFO: Invocation ID: fe5a2542-d550-485a-abd0-1c526bb6175e
INFO: SHA256 (https://golang.org/dl/?mode=json&include=all) = 6efc06a1bd0a710df5cbaa2fd314f9a3f702f7d9cd59ee2bd53c2a02aa8c4475
<... redacted for brevity ...>
INFO: Analyzed target //cmd/client:binary (153 packages loaded, 8458 targets configured).
INFO: Found 1 target...
Target //cmd/client:binary up-to-date:
  bazel-bin/cmd/client/binary_/binary
INFO: Elapsed time: 200.377s, Critical Path: 22.22s
INFO: 350 processes: 15 internal, 335 linux-sandbox.
INFO: Build completed successfully, 350 total actions
```

*bazelisk* passes the `build` sub command to *bazel* with path similar to what was seen before, but also includes `:binary` at the end. Since the [./cmd/client/BUILD.bazel](../cmd/client/BUILD.bazel) file has multiple targets in it, the `:binary` is used to specify which target to use. In this case the target looks like:

```starlark
go_binary(
    name = "binary",
    embed = [":client_lib"],
    visibility = ["//visibility:public"],
)
```

The Go binary was built and stored in the cache. It can be found at:

```sh
ls -alh ./bazel-bin/cmd/client/binary_

total 11M
drwxr-xr-x. 1 user user  90 Jun 30 16:17 .
drwxr-xr-x. 1 user user  46 Jun 30 16:17 ..
-r-xr-xr-x. 1 user user 11M Jun 30 16:17 binary
drwxr-xr-x. 1 user user  28 Jun 30 16:16 binary.runfiles
-r-xr-xr-x. 1 user user 173 Jun 30 16:16 binary.runfiles_manifest
```

This is the real Go binary and it can be ran locally with:

```sh
./bazel-bin/cmd/client/binary_/binary

2021/06/30 16:19:36 checking for configMap file at: ./wizards-server-configMap.txt
2021/06/30 16:19:36 did not find config file: ./wizards-server-configMap.txt. using Kubernetes environment
2021/06/30 16:19:37 # -------------------------------------- #
2021/06/30 16:19:37 requesting list of wizards from the server
2021/06/30 16:19:37 # -------------------------------------- #
^C                                                 
```
The application starts up as expected. Use `ctrl+c` to stop the program.

*bazel* can also run the program using the same target as above but with a different sub command:

```sh
bazelisk run //cmd/client:binary

INFO: Invocation ID: 2e43d3d8-9841-4820-8ed9-d01d9666c450
<... omitted for brevity ...>
INFO: Analyzed target //cmd/client:binary (0 packages loaded, 0 targets configured).
INFO: Found 1 target...
Target //cmd/client:binary up-to-date:
  bazel-bin/cmd/client/binary_/binary
INFO: Elapsed time: 0.311s, Critical Path: 0.00s
INFO: 1 process: 1 internal.
INFO: Build completed successfully, 1 total action
INFO: Build completed successfully, 1 total action
2021/06/30 16:34:10 checking for configMap file at: ./wizards-server-configMap.txt
2021/06/30 16:34:10 did not find config file: ./wizards-server-configMap.txt. using Kubernetes environment
2021/06/30 16:34:11 # -------------------------------------- #
2021/06/30 16:34:11 requesting list of wizards from the server
2021/06/30 16:34:11 # -------------------------------------- #
^C
```

The program starts up the same way, but with some extra *bazel*-specific information that has been omitted due to brevity.

#### Automatic Dependency Builds and Injection

Building the *client* binary took a single command. However, the *client* had several dependencies. *bazel* took care of this for us. With that single `build` command the following happened automatically:
* installed the Go SDK in the cache at the version specified in the [WORKSPACE](../WORKSPACE) file
* analyzed the target and noticed the binary had dependent libraries
* analyzed those dependent libraries and noticed they had a dependency on protobuf
* found the protobuf definition for the `wizard` package, installed protoc and proto-gen-go, and built the Go gRPC client package
* built the Go libraries needed by the client
* built the client Go binary

All of this was done and each step was saved in the cache. Now, future changes to any step in this process only requires rebuilding that part and its dependents. *bazel* keeps track of all of this.

### Building the Client Docker Image

The [./cmd/client/BUILD.bazel](../cmd/client/BUILD.bazel) file has been structured to have two parts. The first part of the generated code provided by *gazelle* for building the Go binary and listing any dependent libraries it has. The second part was added by the CODEOWNER so that the *client* can be built into a Docker Image and deployed as a Docker Container anywhere the supports Docker, probably Kubernetes.

Building a Docker Image requires a couple of things added to the [./cmd/client/BUILD.bazel](../cmd/client/BUILD.bazel):
* load the Docker container rules
* build a Docker image with the Go binary from a base Docker image pulled in the [WORKSPACE](../WORKSPACE) file
* tag and push the image to a specified registry

Let's build a Docker image.

```sh
bazelisk build //cmd/client:image

INFO: Invocation ID: a17aec22-81a8-46c5-b7bf-85f9414ac66e
<... omitted ...>
INFO: Analyzed target //cmd/client:image (1 packages loaded, 4 targets configured).
INFO: Found 1 target...
Target //cmd/client:image up-to-date:
  bazel-bin/cmd/client/image-layer.tar
INFO: Elapsed time: 2.106s, Critical Path: 1.75s
INFO: 25 processes: 2 internal, 23 linux-sandbox.
INFO: Build completed successfully, 25 total actions
```

Great! It made a Docker Image, right. Let's look at the local Docker images.

```sh
docker images

REPOSITORY                                  TAG             IMAGE ID       CREATED        SIZE
```

Wait? There aren't any Docker Images on the system. But there actually are! Remember, *bazel* uses a cache and Docker is just a wrapper around tar files. The file needs to be loaded into the localhost's Docker Daemon. Run the following command to make it available to the system.

```sh
bazelisk run //cmd/client:image

INFO: Invocation ID: dd469a22-fd64-4f4d-81bb-a904c4cdcecd
<... omitted ...>
INFO: Analyzed target //cmd/client:image (0 packages loaded, 0 targets configured).
INFO: Found 1 target...
Target //cmd/client:image up-to-date:
  bazel-bin/cmd/client/image-layer.tar
INFO: Elapsed time: 0.340s, Critical Path: 0.01s
INFO: 1 process: 1 internal.
INFO: Build completed successfully, 1 total action
INFO: Build completed successfully, 1 total action
Loaded image ID: sha256:feedbc8675937f77f1c477a0aa688ced02fe71312c8a7121096a3f0923308659
Tagging feedbc8675937f77f1c477a0aa688ced02fe71312c8a7121096a3f0923308659 as wizter/cmd/client:image
```

Now check Docker again.

```sh
docker images

REPOSITORY                                  TAG             IMAGE ID       CREATED        SIZE
wizter/cmd/client                           image           5b735b1a461c   51 years ago   23.8MB
```

The `run` command takes the built artifact and loads it into the Docker Daemon to make it available to the localhost.

Run the Image to make sure it works.

```sh
docker run -ti wizter/cmd/client:image 

2021/06/30 22:50:06 checking for configMap file at: ./wizards-server-configMap.txt
2021/06/30 22:50:06 did not find config file: ./wizards-server-configMap.txt. using Kubernetes environment
2021/06/30 22:50:07 # -------------------------------------- #
2021/06/30 22:50:07 requesting list of wizards from the server
2021/06/30 22:50:07 # -------------------------------------- #
^C
```

The *client* logs the expected output from a Docker Container, running from an Image that was built from a *bazel* process. Well done.

### Pushing the Docker Image

The final target of [./cmd/client/BUILD.bazel](../cmd/client/BUILD.bazel) includes the ability to push a Docker Image to a registry. The current implementation will fail because the `repository` field of the `container_push()` target is set to: `"<your_docker_hub_id>/wizter/binary"`. Make sure to update this line for the *client* and the *server* before running this *bazel* target like so: `bazelisk run //cmd/client:push`. 

### Clean Up

This concludes the demonstration. It is possible to clean up the local *bazel* cache by running `bazelisk clean`. 